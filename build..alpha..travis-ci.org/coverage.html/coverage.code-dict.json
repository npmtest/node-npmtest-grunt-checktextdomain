{"/home/travis/build/npmtest/node-npmtest-grunt-checktextdomain/test.js":"/* istanbul instrument in package npmtest_grunt_checktextdomain */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-checktextdomain/lib.npmtest_grunt_checktextdomain.js":"/* istanbul instrument in package npmtest_grunt_checktextdomain */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_grunt_checktextdomain = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_grunt_checktextdomain = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-checktextdomain/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-grunt-checktextdomain && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_grunt_checktextdomain */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_grunt_checktextdomain\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_grunt_checktextdomain.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_grunt_checktextdomain.rollup.js'] =\n            local.assetsDict['/assets.npmtest_grunt_checktextdomain.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_grunt_checktextdomain.__dirname + '/lib.npmtest_grunt_checktextdomain.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-checktextdomain/node_modules/grunt-checktextdomain/Gruntfile.js":"/* jshint -W099 */\n/*\n * grunt-checktextdomain\n * https://github.com/stephenharris/grunt-checktextdomain\n *\n * Copyright (c) 2013 Stephen Harris\n * Licensed under the MIT license.\n */\n\n'use strict';\n\n//For convenience store keywards in global\nvar keywords = [\n\t'__:1,2d',\n\t'_e:1,2d',\n\t'_x:1,2c,3d',\n\t'esc_html__:1,2d',\n\t'esc_html_e:1,2d',\n\t'esc_html_x:1,2c,3d',\n\t'esc_attr__:1,2d', \n\t'esc_attr_e:1,2d', \n\t'esc_attr_x:1,2c,3d', \n\t'_ex:1,2c,3d',\n\t'_n:1,2,4d', \n\t'_nx:1,2,4c,5d',\n\t'_n_noop:1,2,3d',\n\t'_nx_noop:1,2,3c,4d'\n\t];\n\nmodule.exports = function(grunt) {\n\t\n  // Project configuration.\n  grunt.initConfig({\n    jshint: {\n      all: [\n        'Gruntfile.js',\n        'tasks/*.js',\n        '<%= nodeunit.tests %>',\n      ],\n      options: {\n        jshintrc: '.jshintrc',\n      },\n    },\n\n    // Before generating any new files, remove any previously-created files.\n    clean: {\n      tests: ['test/tmp'],\n    },\n    \n    copy: {\n    \ttests: {\n    \t\tfiles: [\n    \t\t  //includes files within path\n    \t      //{expand: true, src: ['test/fixtures/*'], dest: 'test/tmp', filter: 'isFile'},\n    \t      // makes all src relative to cwd\n    \t      {expand: true, cwd: 'test/fixtures', src: ['**'], dest: 'test/tmp/'},\n    \t    ]\n    \t  }\n    },\n\n    // Configuration to be run (and then tested).\n    checktextdomain: {\n    \tcorrect_domain: {\n    \t\toptions:{\n    \t\t\tforce: true,\n    \t\t\ttext_domain: 'my-domain',\n    \t\t\tcreate_report_file: true,\n    \t\t\tkeywords: keywords\n        \t},\n        \tfiles: [{\n        \t\tsrc: ['test/tmp/correct-domain.php'],\n        \t\texpand: true,\n        \t}],\n\t\t},\n    \tmissing_domain: {\n    \t\toptions:{\n    \t\t\tforce: true,\n    \t\t\ttext_domain: 'my-domain',\n    \t\t\tcreate_report_file: true,\n    \t\t\tkeywords: keywords\n        \t},\n        \tfiles: [{\n        \t\tsrc: ['test/tmp/missing-domain.php'],\n        \t\texpand: true,\n        \t}],\n\t\t},\n    \tmissing_domain_ignore_missing: {\n    \t\toptions:{\n    \t\t\tforce: true,\n    \t\t\ttext_domain: 'my-domain',\n    \t\t\treport_missing: false,\n    \t\t\tcreate_report_file: true,\n    \t\t\tkeywords: keywords\n        \t},\n        \tfiles: [{\n        \t\tsrc: ['test/tmp/missing-domain.php'],\n        \t\texpand: true,\n        \t}],\n\t\t},\n    \tincorrect_domain_autocomplete: {\n    \t\toptions:{\n    \t\t\tforce: true,\n    \t\t\ttext_domain: 'my-domain',\n    \t\t\tcorrect_domain: true,\n    \t\t\tcreate_report_file: true,\n    \t\t\tkeywords: keywords\n        \t},\n        \tfiles: [{\n        \t\tsrc: ['test/tmp/incorrect-domain-autocorrect.php'],\n        \t\texpand: true,\n        \t}],\n\t\t},\n    \tvariable_domain_autocomplete: {\n    \t\toptions:{\n    \t\t    force: true,\n    \t\t\ttext_domain: 'my-domain',\n    \t\t\tcorrect_domain: true,\n    \t\t\tcreate_report_file: true,\n    \t\t\tkeywords: keywords\n        \t},\n        \tfiles: [{\n        \t\tsrc: ['test/tmp/variable-domain-autocorrect.php'],\n        \t\texpand: true,\n        \t}],\n\t\t},\n    \tplurals: {\n    \t\toptions:{\n    \t\t    force: true,\n    \t\t\ttext_domain: 'my-domain',\n    \t\t\tcreate_report_file: true,\n    \t\t\tkeywords: keywords\n        \t},\n        \tfiles: [{\n        \t\tsrc: ['test/tmp/plurals.php'],\n        \t\texpand: true,\n        \t}],\n\t\t}\n    },\n\n    // Unit tests.\n    nodeunit: {\n      tests: ['test/*_test.js'],\n    },\n\n  });\n\n  // Actually load this plugin's task(s).\n  grunt.loadTasks('tasks');\n\n  // These plugins provide necessary tasks.\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-contrib-clean');\n  grunt.loadNpmTasks('grunt-contrib-copy');\n  grunt.loadNpmTasks('grunt-contrib-nodeunit');\n\n  // Whenever the \"test\" task is run, first clean the \"tmp\" dir, then copy in the futures, then run this\n  // plugin's task(s), then test the result.\n  grunt.registerTask('test', ['clean', 'copy', 'checktextdomain', 'nodeunit']);\n\n  // By default, lint and run all tests.\n  grunt.registerTask('default', ['jshint', 'test']);\n\n};\n","/home/travis/build/npmtest/node-npmtest-grunt-checktextdomain/node_modules/grunt-checktextdomain/tasks/checktextdomain.js":"/*\n * grunt-checktextdomain\n * https://github.com/stephenharris/grunt-checktextdomain\n *\n * Copyright (c) 2013 Stephen Harris\n * Licensed under the MIT license.\n */\n/* jshint -W099 */\n/* jshint -W030 */\n/* jshint -W084 */\n'use strict';\nvar chalk = require('chalk');\nvar table = require('text-table');\nmodule.exports = function(grunt) {\n\n  // Please see the Grunt documentation for more information regarding task\n  // creation: http://gruntjs.com/creating-tasks\n\ngrunt.registerMultiTask('checktextdomain', 'Checks gettext function calls for missing or incorrect text domain.', function() {\n\t// Merge task-specific and/or target-specific options with these defaults.\n\tvar options = this.options({\n\t\tkeywords: false,\n\t\ttext_domain: false,\n\t\treport_missing: true,\n\t\treport_variable_domain: true,\n\t\tcorrect_domain: false,\n\t\tcreate_report_file: false,\n\t\tforce: false,\n\t});\n\t\n\tgrunt.verbose.writeflags( options );\n\n\tif( options.text_domain === false ){\n\t\tgrunt.fail.warn(\"Text domain not provided.\");\n\t}\n\t\n\t//Cast text_domain as an array to support multiple text domains\n\toptions.text_domain = ( options.text_domain instanceof Array ) ? options.text_domain : [options.text_domain];\n\t\n\t//correct_domain can only be used if one domain is specified:\n\toptions.correct_domain = options.correct_domain && ( options.text_domain.length === 1 ); \n\n\tif( options.keywords === false ){\n\t\tgrunt.fail.warn(\"No keywords specified.\");\n\t}\n\n\t//Init the variables\n\tvar errors = [];\n\tvar functions = []; //Array of gettext functions \n\tvar func_domain = {}; //Map of gettext function => ordinal number of domain argument\n\tvar patt = new RegExp(\"([0-9]+)d\", \"i\");\t//Check for domain identifier in keyword specification\n\n\t//Parse keywords for gettext function names and ordinal number of domain argument\n\toptions.keywords.forEach( function(keyword) {\n\n\t\t//parts[0] is keyword name, e.g. __ or _x\n\t\tvar parts = keyword.split(':');\n\t\tvar name = parts[0];\n\t\tvar argument = 0;\n\n\t\t//keyword argument identifiers\n\t\tif( parts.length > 1 ){\n\t\t\tvar args = parts[1];\n\t\t\tvar arg_parts = args.split(',');\n\t\t\t\n\t\t\tfor( var j=0; j < arg_parts.length; j++ ){\n\n\t\t\t\t//check for domain identifier\n\t\t\t\tif( patt.test(arg_parts[j]) ){\n\t\t\t\t\targument = parseInt( patt.exec( arg_parts[j] ), 10 );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//No domain identifier found, assume it is #ags + 1\n\t\t\targument = argument ? argument : arg_parts.length + 1;\n\t\t\t\n\t\t//keyword has no argument identifiers -- assume text domain is 2nd argument\n\t\t}else{\n\t\t\targument = 2;\n\t\t}\n\n\t\tfunc_domain[name] = argument;\n\t\tfunctions.push( name );\n\t});\n\n\tgrunt.verbose.writeflags(func_domain, 'Keywords:');\n\n\n\tvar all_errors = {};\n\tvar error_num = 0;\n\t\n\t// Iterate over all specified file groups.\n\tthis.files.forEach(function(f) {\n\n\t\tvar modified_content = \"\";\n\t\t\n\t\t//Read file, if it exists\n\t\tvar filepath = f.src.join(options.cwd || '', f.src);\n\t\tif ( !grunt.file.exists(filepath ) ) {\n\t\t\tgrunt.log.warn('Source file \"' + filepath + '\" not found.');\n\t\t\treturn;\n\t\t}\n\t\n\t\t//Get tokens\n\t\tvar tokens = checktextdomain.token_get_all( grunt.file.read( filepath ) );\n\t\n\t\t//Init gettext_func - the current gettext function being inspected\n\t\tvar gettext_func = {\n\t\t\tname: false, //The name of the gettext function\n\t\t\tline: false, //The line it occurs on\n\t\t\tdomain: false, //The domain used with it (false if not found)\n\t\t\targument: 0, //Ordinal argument number we are currently in\n\t\t};\n\n\t\tvar parens_balance = 0; //Used to track parenthesis\n\n\t\tfor( var i=0; i<tokens.length; i++ ){\n\n\t\t\tvar token = tokens[i][0], text = tokens[i][1], line = tokens[i][2];\n\t\t\t\n\t\t\tvar content = ( 'undefined' !== typeof tokens[i][1] ? tokens[i][1] : tokens[i][0] );\n\t\t\t\n\t\t\t//Look for T_STRING (function call )\n\t\t\tif( token === 306 && functions.indexOf( text ) > -1 ){\n\n\t\t\t\tgettext_func ={\n\t\t\t\t\tname: text,\n\t\t\t\t\tline: line,\n\t\t\t\t\tdomain: false,\n\t\t\t\t\targument: 0,\n\t\t\t\t};\n\t\n\t\t\t\tparens_balance = 0;\n\t\t\t\t\n\t\t\t//Check for T_CONSTANT_ENCAPSED_STRING - and that we are in the text-domain argument\n\t\t\t}else if( token === 314 && gettext_func.line && func_domain[gettext_func.name] === gettext_func.argument ){\n\t\n\t\t\t\tif( gettext_func.argument > 0 ){\n\t\t\t\t\tgettext_func.domain = text.substr(1,text.length -2);//get rid of quotes from beginning & end\n\t\t\t\t\t\n\t\t\t\t\t//Corect content\n\t\t\t\t\tif( options.correct_domain && gettext_func.domain !== options.text_domain[0] ){\n\t\t\t\t\t\tcontent = \"'\"+options.text_domain[0]+\"'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t//Check for variable - and that we are in the text-domain argument\n\t\t\t}else if( token === 308 && gettext_func.line && func_domain[gettext_func.name] === gettext_func.argument ){\n\t\n\t\t\t\tif( gettext_func.argument > 0 ){\n\t\t\t\t\tgettext_func.domain = -1; //We don't know what the domain is )its a variable).\n\t\t\t\t\t\n\t\t\t\t\t//Corect content\n\t\t\t\t\tif( options.report_variable_domain && options.correct_domain ){\n\t\t\t\t\t\tcontent = \"'\"+options.text_domain[0]+\"'\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t//Check for comma seperating arguments. Only interested in 'top level' where parens_balance == 1\n\t\t\t}else if ( token === ',' && parens_balance === 1 && gettext_func.line ){\n\t\t\t\tgettext_func.argument++;\n\t\n\t\t\t//If we are an opening bracket, increment parens_balance\n\t\t\t}else if( '(' === token && gettext_func.line  ){\n\t\t\t\t\n\t\t\t\t//If in gettext function and found opening parenthesis, we are at first argument\n\t\t\t\tif( gettext_func.argument === 0 ){\n\t\t\t\t\tgettext_func.argument = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tparens_balance++;\n\t\n\t\t\t//If in gettext function and found closing parenthesis,\n\t\t\t}else if( ')' === token && gettext_func.line ){\n\t\t\t\tparens_balance--;\n\n\t\t\t\t//If parenthesis match we have parsed all the function's arguments. Time to tally.\n\t\t\t\tif ( gettext_func.line && 0 === parens_balance ) {\n\t\n\t\t\t\t\tvar error_type = false;\n\t\t\t\t\t\n\t\t\t\t\tif( ( options.report_variable_domain && gettext_func.domain === -1 ) ){\n\t\t\t\t\t\terror_type = 'variable-domain'; \n\t\t\t\t\t\t\t\n\t\t\t\t\t}else if( options.report_missing && !gettext_func.domain ){ \n\t\t\t\t\t\terror_type = 'missing-domain';\n\t\t\t\t\t\t\n\t\t\t\t\t}else if( gettext_func.domain && gettext_func.domain !== -1 && options.text_domain.indexOf( gettext_func.domain ) === -1 ) {\n\t\t\t\t\t\terror_type = 'incorrect-domain';\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( error_type ){\n\t\t\t\t\t\terrors.push( gettext_func );\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Reset gettext_func\n\t\t\t\t\tgettext_func = {\n\t\t\t\t\t\tname: false,\n\t\t\t\t\t\tline: false,\n\t\t\t\t\t\tdomain: false,\n\t\t\t\t\t\targument: 0,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tmodified_content += content;\n\n\t\t}\n\t\t\n\t\t//Output errors\n\t\tif( errors.length > 0 ){\n\n\t\t\tconsole.log( \"\\n\" + chalk.bold.underline(f.src));\n\n\t\t\tvar rows = [],error_line,func,message;\n\t\t\tfor( i = 0; i < errors.length; i++ ){\n\n\t\t\t\terror_line = chalk.yellow(grunt.template.process('[L<%= line %>]', {data: errors[i]}) );\n\t\t\t\tfunc = chalk.cyan(errors[i].name);\n\t\t\t\n\t\t\t\tif(  !errors[i].domain ) {\n\t\t\t\t\tmessage =  chalk.red( 'Missing text domain' );\n\t\t\t\t\n\t\t\t\t}else if(  errors[i].domain === -1 ) {\n\t\t\t\t\tmessage =  chalk.red( 'Variable used in domain argument' );\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tmessage =  chalk.red( grunt.template.process('Incorrect text domain used (\"<%= domain %>\")', {data: errors[i]}) );\n\t\t\t\t}\n\t\t\t\n\t\t\t\trows.push( [ error_line, func, message ] );\n\t\t\t\terror_num++;\n\t\t\t}\n\t\t\t\n\t\t\tconsole.log( table(rows) );\n\t\t\t\n\t\t\tif( options.correct_domain ){\n\t\t\t\tgrunt.file.write( filepath, modified_content );\n\t\t\t\tconsole.log( chalk.bold( filepath + \" corrected.\" ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tall_errors[filepath] = errors;\n\t\t\n\t\t//Reset errors\n\t\terrors = [];\n    });\n\n\t\n\tif( options.create_report_file ){\n\t\tgrunt.file.write( \".\" + this.target +\".json\", JSON.stringify( all_errors ) );\n\t}\n\n\tif ( error_num > 0 && !options.force ) {\n\t\tgrunt.fail.warn( error_num + ' problem' + (error_num === 1 ? '' : 's'), 6 );\n\t}else if( error_num > 0 ){\n\t\tconsole.log( \"\\n\" + chalk.red.bold('✖ ' + error_num + ' problem' + (error_num === 1 ? '' : 's')) );\n\t} else {\n\t\tconsole.log( \"\\n\" + chalk.green.bold('✔ No problems') +  \"\\n\" );\n\t}\n\n  });\n\nvar checktextdomain = {};\nchecktextdomain.token_get_all = function (source) {\n\t// Split given source into PHP tokens\n\t// + original by: Marco Marchiò\n\t// + improved by: Brett Zamir (http://brett-zamir.me)\n\t// - depends on: token_name\n\t// % note 1: Token numbers depend on the PHP version\n\t// % note 2: token_name is only necessary for a non-standard php.js-specific use of this function;\n\t// % note 2: if you define an object on this.php_js.phpParser (where \"this\" is the scope of the\n\t// % note 2: token_get_all function (either a namespaced php.js object or the window object)),\n\t// % note 2: this function will call that object's methods if they have the same names as the tokens,\n\t// % note 2: passing them the string, line number, and token number (in that order)\n\t// * example 1: token_get_all('/'+'* comment *'+'/');\n\t// * returns 1: [[310, '/* comment */', 1]]\n\n\t// Token to number conversion\n    var num,\n        nextch,\n        word,\n        ch,\n        sym,\n        ASCII,\n        i = 0,\n        that = this,\n        length = source.length,\n        //Regexp to check if the characters that follow a word are valid as heredoc end declaration\n        heredocEndFollowing = /^;?\\r?\\n/,\n        tokens = {\n            T_REQUIRE_ONCE: 261,\n            T_REQUIRE: 260,\n            T_EVAL: 259,\n            T_INCLUDE_ONCE: 258,\n            T_INCLUDE: 257,\n            T_LOGICAL_OR: 262,\n            T_LOGICAL_XOR: 263,\n            T_LOGICAL_AND: 264,\n            T_PRINT: 265,\n            T_SR_EQUAL: 276,\n            T_SL_EQUAL: 275,\n            T_XOR_EQUAL: 274,\n            T_OR_EQUAL: 273,\n            T_AND_EQUAL: 272,\n            T_MOD_EQUAL: 271,\n            T_CONCAT_EQUAL: 270,\n            T_DIV_EQUAL: 269,\n            T_MUL_EQUAL: 268,\n            T_MINUS_EQUAL: 267,\n            T_PLUS_EQUAL: 266,\n            T_BOOLEAN_OR: 277,\n            T_BOOLEAN_AND: 278,\n            T_IS_NOT_IDENTICAL: 282,\n            T_IS_IDENTICAL: 281,\n            T_IS_NOT_EQUAL: 280,\n            T_IS_EQUAL: 279,\n            T_IS_GREATER_OR_EQUAL: 284,\n            T_IS_SMALLER_OR_EQUAL: 283,\n            T_SR: 286,\n            T_SL: 285,\n            T_INSTANCEOF: 287,\n            T_UNSET_CAST: 296,\n            T_BOOL_CAST: 295,\n            T_OBJECT_CAST: 294,\n            T_ARRAY_CAST: 293,\n            T_STRING_CAST: 292,\n            T_DOUBLE_CAST: 291,\n            T_INT_CAST: 290,\n            T_DEC: 289,\n            T_INC: 288,\n            T_CLONE: 298,\n            T_NEW: 297,\n            T_EXIT: 299,\n            T_IF: 300,\n            T_ELSEIF: 301,\n            T_ELSE: 302,\n            T_ENDIF: 303,\n            T_LNUMBER: 304,\n            T_DNUMBER: 305,\n            T_STRING: 306,\n            T_STRING_VARNAME: 307,\n            T_VARIABLE: 308,\n            T_NUM_STRING: 309,\n            T_INLINE_HTML: 310,\n            T_CHARACTER: 311,\n            T_BAD_CHARACTER: 312,\n            T_ENCAPSED_AND_WHITESPACE: 313,\n            T_CONSTANT_ENCAPSED_STRING: 314,\n            T_ECHO: 315,\n            T_DO: 316,\n            T_WHILE: 317,\n            T_ENDWHILE: 318,\n            T_FOR: 319,\n            T_ENDFOR: 320,\n            T_FOREACH: 321,\n            T_ENDFOREACH: 322,\n            T_DECLARE: 323,\n            T_ENDDECLARE: 324,\n            T_AS: 325,\n            T_SWITCH: 326,\n            T_ENDSWITCH: 327,\n            T_CASE: 328,\n            T_DEFAULT: 329,\n            T_BREAK: 330,\n            T_CONTINUE: 331,\n            T_GOTO: 332,\n            T_FUNCTION: 333,\n            T_CONST: 334,\n            T_RETURN: 335,\n            T_TRY: 336,\n            T_CATCH: 337,\n            T_THROW: 338,\n            T_USE: 339,\n            T_GLOBAL: 340,\n            T_PUBLIC: 346,\n            T_PROTECTED: 345,\n            T_PRIVATE: 344,\n            T_FINAL: 343,\n            T_ABSTRACT: 342,\n            T_STATIC: 341,\n            T_VAR: 347,\n            T_UNSET: 348,\n            T_ISSET: 349,\n            T_EMPTY: 350,\n            T_HALT_COMPILER: 351,\n            T_CLASS: 352,\n            T_INTERFACE: 353,\n            T_EXTENDS: 354,\n            T_IMPLEMENTS: 355,\n            T_OBJECT_OPERATOR: 356,\n            T_DOUBLE_ARROW: 357,\n            T_LIST: 358,\n            T_ARRAY: 359,\n            T_CLASS_C: 360,\n            T_METHOD_C: 361,\n            T_FUNC_C: 362,\n            T_LINE: 363,\n            T_FILE: 364,\n            T_COMMENT: 365,\n            T_DOC_COMMENT: 366,\n            T_OPEN_TAG: 367,\n            T_OPEN_TAG_WITH_ECHO: 368,\n            T_CLOSE_TAG: 369,\n            T_WHITESPACE: 370,\n            T_START_HEREDOC: 371,\n            T_END_HEREDOC: 372,\n            T_DOLLAR_OPEN_CURLY_BRACES: 373,\n            T_CURLY_OPEN: 374,\n            T_PAAMAYIM_NEKUDOTAYIM: 375,\n            T_NAMESPACE: 376,\n            T_NS_C: 377,\n            T_DIR: 378,\n            T_NS_SEPARATOR: 379\n        },\n        //Keywords tokens\n        keywordsToken = {\n            \"abstract\": tokens.T_ABSTRACT,\n            \"array\": tokens.T_ARRAY,\n            \"as\": tokens.T_AS,\n            \"break\": tokens.T_BREAK,\n            \"case\": tokens.T_CASE,\n            \"catch\": tokens.T_CATCH,\n            \"class\": tokens.T_CLASS,\n            \"__CLASS__\": tokens.T_CLASS_C,\n            \"clone\": tokens.T_CLONE,\n            \"const\": tokens.T_CONST,\n            \"continue\": tokens.T_CONTINUE,\n            \"declare\": tokens.T_DECLARE,\n            \"default\": tokens.T_DEFAULT,\n            \"__DIR__\": tokens.T_DIR,\n            \"die\": tokens.T_EXIT,\n            \"do\": tokens.T_DO,\n            \"echo\": tokens.T_ECHO,\n            \"else\": tokens.T_ELSE,\n            \"elseif\": tokens.T_ELSEIF,\n            \"empty\": tokens.T_EMPTY,\n            \"enddeclare\": tokens.T_ENDDECLARE,\n            \"endfor\": tokens.T_ENDFOR,\n            \"endforeach\": tokens.T_ENDFOREACH,\n            \"endif\": tokens.T_ENDIF,\n            \"endswitch\": tokens.T_ENDSWITCH,\n            \"endwhile\": tokens.T_ENDWHILE,\n            \"eval\": tokens.T_EVAL,\n            \"exit\": tokens.T_EXIT,\n            \"extends\": tokens.T_EXTENDS,\n            \"__FILE__\": tokens.T_FILE,\n            \"final\": tokens.T_FINAL,\n            \"for\": tokens.T_FOR,\n            \"foreach\": tokens.T_FOREACH,\n            \"function\": tokens.T_FUNCTION,\n            \"__FUNCTION__\": tokens.T_FUNC_C,\n            \"global\": tokens.T_GLOBAL,\n            \"goto\": tokens.T_GOTO,\n            \"__halt_compiler\": tokens.T_HALT_COMPILER,\n            \"if\": tokens.T_IF,\n            \"implements\": tokens.T_IMPLEMENTS,\n            \"include\": tokens.T_INCLUDE,\n            \"include_once\": tokens.T_INCLUDE_ONCE,\n            \"instanceof\": tokens.T_INSTANCEOF,\n            \"interface\": tokens.T_INTERFACE,\n            \"isset\": tokens.T_ISSET,\n            \"__LINE__\": tokens.T_LINE,\n            \"list\": tokens.T_LIST,\n            \"and\": tokens.T_LOGICAL_AND,\n            \"or\": tokens.T_LOGICAL_OR,\n            \"xor\": tokens.T_LOGICAL_XOR,\n            \"__METHOD__\": tokens.T_METHOD_C,\n            \"namespace\": tokens.T_NAMESPACE,\n            \"__NAMESPACE__\": tokens.T_NS_C,\n            \"new\": tokens.T_NEW,\n            \"print\": tokens.T_PRINT,\n            \"private\": tokens.T_PRIVATE,\n            \"public\": tokens.T_PUBLIC,\n            \"protected\": tokens.T_PROTECTED,\n            \"require\": tokens.T_REQUIRE,\n            \"require_once\": tokens.T_REQUIRE_ONCE,\n            \"return\": tokens.T_RETURN,\n            \"static\": tokens.T_STATIC,\n            \"switch\": tokens.T_SWITCH,\n            \"throw\": tokens.T_THROW,\n            \"try\": tokens.T_TRY,\n            \"unset\": tokens.T_UNSET,\n            \"use\": tokens.T_USE,\n            \"var\": tokens.T_VAR,\n            \"while\": tokens.T_WHILE\n        },\n        //Type casting tokens\n        typeCasting = {\n            \"array\": tokens.T_ARRAY_CAST,\n            \"bool\": tokens.T_BOOL_CAST,\n            \"boolean\": tokens.T_BOOL_CAST,\n            \"real\": tokens.T_DOUBLE_CAST,\n            \"double\": tokens.T_DOUBLE_CAST,\n            \"float\": tokens.T_DOUBLE_CAST,\n            \"int\": tokens.T_INT_CAST,\n            \"integer\": tokens.T_INT_CAST,\n            \"object\": tokens.T_OBJECT_CAST,\n            \"string\": tokens.T_STRING_CAST,\n            \"unset\": tokens.T_UNSET_CAST,\n            \"binary\": tokens.T_STRING_CAST\n        },\n        //Symbols tokens with 2 characters\n        symbols2chars = {\n            \"&=\": tokens.T_AND_EQUAL,\n            \"&&\": tokens.T_BOOLEAN_AND,\n            \"||\": tokens.T_BOOLEAN_OR,\n            \"?>\": tokens.T_CLOSE_TAG,\n            \"%>\": tokens.T_CLOSE_TAG,\n            \".=\": tokens.T_CONCAT_EQUAL,\n            \"--\": tokens.T_DEC,\n            \"/=\": tokens.T_DIV_EQUAL,\n            \"=>\": tokens.T_DOUBLE_ARROW,\n            \"::\": tokens.T_PAAMAYIM_NEKUDOTAYIM,\n            \"++\": tokens.T_INC,\n            \"==\": tokens.T_IS_EQUAL,\n            \">=\": tokens.T_IS_GREATER_OR_EQUAL,\n            \"!=\": tokens.T_IS_NOT_EQUAL,\n            \"<>\": tokens.T_IS_NOT_EQUAL,\n            \"<=\": tokens.T_IS_SMALLER_OR_EQUAL,\n            \"-=\": tokens.T_MINUS_EQUAL,\n            \"%=\": tokens.T_MOD_EQUAL,\n            \"*=\": tokens.T_MUL_EQUAL,\n            \"->\": tokens.T_OBJECT_OPERATOR,\n            \"|=\": tokens.T_OR_EQUAL,\n            \"+=\": tokens.T_PLUS_EQUAL,\n            \"<<\": tokens.T_SL,\n            \">>\": tokens.T_SR,\n            \"^=\": tokens.T_XOR_EQUAL,\n            \"<?\": tokens.T_OPEN_TAG\n        },\n        //Symbols tokens with 3 characters\n        symbols3chars = {\n            \"===\": tokens.T_IS_IDENTICAL,\n            \"!==\": tokens.T_IS_NOT_IDENTICAL,\n            \"<<=\": tokens.T_SL_EQUAL,\n            \">>=\": tokens.T_SR_EQUAL,\n            \"<?=\": tokens.T_OPEN_TAG_WITH_ECHO,\n            \"<%=\": tokens.T_OPEN_TAG_WITH_ECHO\n        },\n        //Buffer tokens\n        bufferTokens = {\n            \"html\": tokens.T_INLINE_HTML,\n            \"inlineComment\": tokens.T_COMMENT,\n            \"comment\": tokens.T_COMMENT,\n            \"docComment\": tokens.T_DOC_COMMENT,\n            \"singleQuote\": tokens.T_CONSTANT_ENCAPSED_STRING,\n            \"doubleQuotes\": tokens.T_CONSTANT_ENCAPSED_STRING,\n            \"nowdoc\": tokens.T_ENCAPSED_AND_WHITESPACE,\n            \"heredoc\": tokens.T_ENCAPSED_AND_WHITESPACE\n        },\n        //Characters that are emitted as tokens without a code\n        singleTokenChars = \";(){}[],~@`=+/-*.$|^&<>%!?:\\\"'\\\\\",\n        //Buffer type. Start an html buffer immediatelly.\n        bufferType = \"html\",\n        //Buffer content\n        buffer = \"\",\n        //Last emitted token\n        lastToken,\n        //Results array\n        ret = [],\n        //Word that started the heredoc or nowdoc buffer\n        heredocWord,\n        //Line number\n        line = 1,\n        //Line at which the buffer begins\n        lineBuffer = 1,\n        //Flag that indicates if the current double quoted string has been splitted\n        split,\n        //This variable will store the previous buffer type of the tokenizer before parsing a\n        //complex variable syntax\n        complexVarPrevBuffer,\n        //Number of open brackets inside a complex variable syntax\n        openBrackets,\n        //Function to emit tokens\n        emitToken = function (token, code, preventBuffer, l) {\n            if (!preventBuffer && bufferType) {\n                buffer += token;\n                lastToken = null;\n            } else {\n                lastToken = code || token;\n                ret.push(code ? [code, token, l || line] : token);\n            }\n        },\n        //Function to emit and close the current buffer\n        emitBuffer = function () {\n            buffer && emitToken(buffer, bufferTokens[bufferType], true, lineBuffer);\n            buffer = \"\";\n            bufferType = null;\n        },\n        //Function to check if the token at the current index is escaped\n        isEscaped = function (s) {\n            var escaped = false,\n                c = (s || i) - 1;\n            for (; c >= 0; c--) {\n                if (source.charAt(c) !== \"\\\\\") {\n                    break;\n                }\n                escaped = !escaped;\n            }\n            return escaped;\n        },\n        //Returns the number of line feed characters in the given string\n        countNewLines = function (str) {\n            var i = 0;\n            str.replace(/\\n/g, function () {\n                i++;\n            });\n            return i;\n        },\n        //Get the part of source that is between the current index and the index of the limit character\n        getBufferAndEmit = function (start, type, limit, canBeEscaped) {\n            /*23456*/\n            var startL = start.length,\n                startPos = i + startL,\n                pos = source.indexOf(limit, startPos);\n            lineBuffer = line;\n            if (canBeEscaped) {\n                while (pos !== -1 && isEscaped(pos)) {\n                    pos = source.indexOf(limit, pos + 1);\n                }\n            }\n            bufferType = type;\n            if (pos === -1) {\n                buffer = start + source.substr(startPos);\n            } else {\n                buffer = start + source.substr(startPos, pos - startPos) + limit;\n            }\n            line += countNewLines(buffer);\n            emitBuffer();\n            \n        \t//If limit is not found, set i to the position of the end of the buffered characters\n            if(pos === -1){\n            \ti = i + buffer.length;\n            }else{\n            \ti = pos + limit.length - 1;\n            }\n        },\n        //This function is used to split a double quoted string or a heredoc buffer after a variable\n        //has been found inside it\n        splitString = function () {\n            //Don't emit empty buffers\n            if (!buffer) {\n                return;\n            }\n            //If the buffer is a double quoted string and it has not yet been splitted, emit the double\n            //quotes as a token without an associated code\n            if (bufferType === \"doubleQuotes\" && !split) {\n                split = true;\n                emitToken('\"', null, true);\n                buffer = buffer.substr(1);\n            }\n            buffer && emitToken(buffer, tokens.T_ENCAPSED_AND_WHITESPACE, true, lineBuffer);\n            buffer = \"\";\n            lineBuffer = line;\n        },\n        //Checks if the given ASCII identifies a whitespace\n        isWhitespace = function (ASCII) {\n            return ASCII === 9 || ASCII === 10 || ASCII === 13 || ASCII === 32;\n        },\n        //Get next whitespaces\n        getWhitespaces = function () {\n            var as,\n                chr,\n                ret = \"\";\n            for (i++; i < length; i++) {\n                chr = source.charAt(i);\n                as = chr.charCodeAt(0);\n                if (isWhitespace(as)) {\n                    ret += chr;\n                } else {\n                    i--;\n                    break;\n                }\n            }\n            return ret;\n        },\n        //Get next word\n        getWord = function (i) {\n            var match = /^[a-zA-Z_]\\w*/.exec(source.substr(i));\n            return match ? match[0] : null;\n        },\n        //Get next heredoc declaration\n        getHeredocWord = function () {\n            return (/^<<< *(['\"]?[a-zA-Z]\\w*)['\"]?\\r?\\n/).exec(source.substr(i));\n        },\n        //Get next type casting declaration\n        getTypeCasting = function () {\n            var match = (/^\\( *([a-zA-Z]+) *\\)/).exec(source.substr(i));\n            return match && match[1] && (match[1].toLowerCase()) in typeCasting ? match : null;\n        },\n        //Get next php long open declaration\n        getLongOpenDeclaration = function (i) {\n            return (/^php(?:\\r?\\s)?/i).exec(source.substr(i));\n        },\n        //Get next integer or float number\n        getNumber = function () {\n            var rnum = /^(?:((?:\\d+(?:\\.\\d*)?|\\d*\\.\\d+)[eE][\\+\\-]?\\d+|\\d*\\.\\d+|\\d+\\.\\d*)|(\\d+(?:x[0-9a-fA-F]+)?))/,\n                match = rnum.exec(source.substr(i));\n            if (!match) {\n                return null;\n            }\n            if (match[2]) {\n                var isHex = match[2].toLowerCase().indexOf(\"x\") > -1;\n                //If it's greater than 2147483648 it's considered as a floating point number\n                if (parseInt(isHex ? parseInt(match[2], 16) : match[2], 10) < 2147483648) {\n                    return [match[2], tokens.T_LNUMBER];\n                }\n                return [match[2], tokens.T_DNUMBER];\n            }\n            return [match[1], tokens.T_DNUMBER];\n        };\n\n    // Avoid running a conditional for each token by overwriting function\n    if (this.php_js && this.php_js.phpParser) {\n        var oldEmitToken = emitToken;\n        emitToken = function (token, code, preventBuffer, l) {\n            var action = that.php_js.phpParser[typeof token === 'number' ? that.token_name(token) : token];\n            // Allow execution of (optional) parsing callbacks during first run-through\n            if (typeof action === 'function') {\n                action.call(that.php_js.phpParser, code, line, token, preventBuffer, l);\n            }\n            oldEmitToken(token, code, preventBuffer, l);\n        };\n    }\n\n\tfor (; i < length; i++) {\n\t\tch = source.charAt(i);\n\t\tASCII = ch.charCodeAt(0);\n\t\t//Whitespaces\n\t\tif (isWhitespace(ASCII)) {\n\t\t\t//Get next whitespaces too\n\t\t\tch += getWhitespaces();\n\t\t\temitToken(ch, tokens.T_WHITESPACE);\n\t\t\tline += countNewLines(ch);\n\t\t} else if (ch === \"#\" || (ch === \"/\" && ((nextch = source.charAt(i + 1)) === \"*\" || nextch === \"/\"))) {\n\t\t\t//Comment signs\n\t\t\t//Change the buffer only if there's no active buffer\n\t\t\tif (!bufferType) {\n\t\t\t\tif (ch === \"#\") {\n\t\t\t\t\tgetBufferAndEmit(\"#\", \"inlineComment\", \"\\n\");\n\t\t\t\t} else if (ch + nextch === \"//\") {\n\t\t\t\t\tgetBufferAndEmit(\"//\", \"inlineComment\", \"\\n\");\n\t\t\t\t} else if ((ch + nextch + source.charAt(i + 2)) === \"/**\") {\n\t\t\t\t\tgetBufferAndEmit(\n\t\t\t\t\t\t\"/**\",\n\t\t\t\t\t\t//It's a doc comment only if it's followed by a whitespaces\n\t\t\t\t\t\tisWhitespace(source.charCodeAt(i + 3)) ? \"docComment\" : \"comment\",\n\t\t\t\t\t\t\"*/\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tgetBufferAndEmit(\"/*\", \"comment\", \"*/\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\temitToken(ch);\n\t\t} else if (ch === \"$\" && (word = getWord(i + 1))) {\n\t\t\t//Variable\n\t\t\tif ((bufferType === \"heredoc\" || bufferType === \"doubleQuotes\") && !isEscaped()) {\n\t\t\t\tsplitString();\n\t\t\t\temitToken(ch + word, tokens.T_VARIABLE, true);\n\t\t\t} else {\n\t\t\t\temitToken(ch + word, tokens.T_VARIABLE);\n\t\t\t}\n\t\t\ti += word.length;\n\t\t} else if (ch === \"<\" && source.substr(i + 1, 2) === \"<<\" && (word = getHeredocWord())) {\n\t\t\t//Heredoc and nowdoc start declaration\n\t\t\temitToken(word[0], tokens.T_START_HEREDOC);\n\t\t\tline++;\n\t\t\tif (!bufferType) {\n\t\t\t\theredocWord = word[1];\n\t\t\t\t//If the first character is a quote then it's a nowdoc otherwise it's an heredoc\n\t\t\t\tif (heredocWord.charAt(0) === \"'\") {\n\t\t\t\t\t//Strip the leading quote\n\t\t\t\t\theredocWord = heredocWord.substr(1);\n\t\t\t\t\tbufferType = \"nowdoc\";\n\t\t\t\t} else {\n\t\t\t\t\tif (heredocWord.charAt(0) === '\"') {\n\t\t\t\t\t\theredocWord = heredocWord.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\tbufferType = \"heredoc\";\n\t\t\t\t}\n\t\t\t\tlineBuffer = line;\n\t\t\t}\n\t\t\ti += word[0].length - 1;\n\t\t} else if (ch === \"(\" && (word = getTypeCasting())) {\n\t\t\t//Type-casting\n\t\t\temitToken(word[0], typeCasting[word[1].toLowerCase()]);\n\t\t\ti += word[0].length - 1;\n\t\t} else if ((ch === \".\" || (ch >= \"0\" && ch <= \"9\")) && (num = getNumber())) {\n\t\t\t//Numbers\n\t\t\t//Numeric array index inside a heredoc or a double quoted string\n\t\t\tif (lastToken === \"[\" && (bufferType === \"heredoc\" || bufferType === \"doubleQuotes\")) {\n\t\t\t\temitToken(num[0], tokens.T_NUM_STRING, true);\n\t\t\t} else {\n\t\t\t\temitToken(num[0], num[1]);\n\t\t\t}\n\t\t\ti += String(num[0]).length - 1;\n\t\t} else if (singleTokenChars.indexOf(ch) > -1) {\n\t\t\t//Symbols\n\t\t\tsym = source.substr(i, 3);\n\t\t\tif (sym in symbols3chars) {\n\t\t\t\ti += 2;\n\t\t\t\t//If it's a php open tag emit the html buffer\n\t\t\t\tif (bufferType === \"html\" && symbols3chars[sym] === tokens.T_OPEN_TAG_WITH_ECHO) {\n\t\t\t\t\temitBuffer();\n\t\t\t\t}\n\t\t\t\temitToken(sym, symbols3chars[sym]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsym = ch + source.charAt(i + 1);\n\t\t\tif (sym in symbols2chars) {\n\t\t\t\t//If it's a php open tag check if it's written in the long form and emit the html buffer\n\t\t\t\tif (symbols2chars[sym] === tokens.T_OPEN_TAG && bufferType === \"html\") {\n\t\t\t\t\temitBuffer();\n\t\t\t\t\ti++;\n\t\t\t\t\tif (word = getLongOpenDeclaration(i + 1)) {\n\t\t\t\t\t\ti += word[0].length;\n\t\t\t\t\t\tsym += word[0];\n\t\t\t\t\t}\n\t\t\t\t\temitToken(sym, tokens.T_OPEN_TAG);\n\t\t\t\t\tif (sym.indexOf(\"\\n\") > -1) {\n\t\t\t\t\t\tline++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\t//Syntax $obj->prop inside strings and heredoc\n\t\t\t\tif (sym === \"->\" && lastToken === tokens.T_VARIABLE && (bufferType === \"heredoc\" ||\n\t\t\t\t\tbufferType === \"doubleQuotes\")) {\n\t\t\t\t\temitToken(sym, symbols2chars[sym], true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\temitToken(sym, symbols2chars[sym]);\n\t\t\t\t//If the token is a PHP close tag and there isn't an active buffer start an html buffer\n\t\t\t\tif (!bufferType && symbols2chars[sym] === tokens.T_CLOSE_TAG) {\n\t\t\t\t\t//PHP closing tag includes the following new line characters\n\t\t\t\t\tif (nextch = /^\\r?\\n/.exec(source.substr(i + 1, 2))) {\n\t\t\t\t\t\tret[ret.length - 1][1] += nextch[0];\n\t\t\t\t\t\ti += nextch[0].length;\n\t\t\t\t\t\tline++;\n\t\t\t\t\t}\n\t\t\t\t\tbufferType = \"html\";\n\t\t\t\t\tlineBuffer = line;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//Start string buffers if there isn't an active buffer and the character is a quote\n\t\t\tif (!bufferType && (ch === \"'\" || ch === '\"')) {\n\t\t\t\tif (ch === \"'\") {\n\t\t\t\t\tgetBufferAndEmit(\"'\", \"singleQuote\", \"'\", true);\n\t\t\t\t} else {\n\t\t\t\t\tsplit = false;\n\t\t\t\t\tbufferType = \"doubleQuotes\";\n\t\t\t\t\tlineBuffer = line;\n\t\t\t\t\t//Add the token to the buffer and continue to skip next checks\n\t\t\t\t\temitToken(ch);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ch === '\"' && bufferType === \"doubleQuotes\" && !isEscaped()) {\n\t\t\t\t//If the string has been splitted emit the current buffer and the double quotes\n\t\t\t\t//as separate tokens\n\t\t\t\tif (split) {\n\t\t\t\t\tsplitString();\n\t\t\t\t\tbufferType = null;\n\t\t\t\t\temitToken('\"');\n\t\t\t\t} else {\n\t\t\t\t\temitToken('\"');\n\t\t\t\t\temitBuffer();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (bufferType === \"heredoc\" || bufferType === \"doubleQuotes\") {\n\t\t\t\t//Array index delimiters inside heredoc or double quotes\n\t\t\t\tif ((ch === \"[\" && lastToken === tokens.T_VARIABLE) ||\n                        (ch === \"]\" && (lastToken === tokens.T_NUM_STRING ||\n                        lastToken === tokens.T_STRING))) {\n\t\t\t\t\temitToken(ch, null, true);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (((ch === \"$\" && source.charAt(i + 1) === \"{\") ||\n\t\t\t\t\t\t\t(ch === \"{\" && source.charAt(i + 1) === \"$\")) &&\n\t\t\t\t\t\t\t!isEscaped()) {\n\t\t\t\t\t//Complex variable syntax ${varname} or {$varname}. Store the current\n\t\t\t\t\t//buffer type and evaluate next tokens as there's no active buffer.\n\t\t\t\t\t//The current buffer will be reset when the declaration is closed\n\t\t\t\t\tsplitString();\n\t\t\t\t\tcomplexVarPrevBuffer = bufferType;\n\t\t\t\t\tbufferType = null;\n\t\t\t\t\tif (ch === \"$\") {\n\t\t\t\t\t\temitToken(ch + \"{\", tokens.T_DOLLAR_OPEN_CURLY_BRACES);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temitToken(ch, tokens.T_CURLY_OPEN);\n\t\t\t\t\t}\n\t\t\t\t\topenBrackets = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (ch === \"\\\\\") {\n\t\t\t\t//Namespace separator\n\t\t\t\temitToken(ch, tokens.T_NS_SEPARATOR);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\temitToken(ch);\n\t\t\t//Increment or decrement the number of open brackets inside a complex\n\t\t\t//variable syntax\n\t\t\tif (complexVarPrevBuffer && (ch === \"{\" || ch === \"}\")) {\n\t\t\t\tif (ch === \"{\") {\n\t\t\t\t\topenBrackets++;\n\t\t\t\t} else if (!--openBrackets) {\n\t\t\t\t\t//If every bracket has been closed reset the previous buffer\n\t\t\t\t\tbufferType = complexVarPrevBuffer;\n\t\t\t\t\tcomplexVarPrevBuffer = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (word = getWord(i)) {\n\t\t\t//Words\n\t\t\tvar wordLower = word.toLowerCase();\n\t\t\t//Check to see if it's a keyword\n\t\t\tif (keywordsToken.hasOwnProperty(word) || keywordsToken.hasOwnProperty(wordLower)) {\n\t\t\t\t//If it's preceded by -> than it's an object property and it must be tokenized as T_STRING\n\t\t\t\temitToken(\n\t\t\t\t\tword,\n\t\t\t\t\tlastToken === tokens.T_OBJECT_OPERATOR ?\n                        tokens.T_STRING :\n                        keywordsToken[word] || keywordsToken[wordLower]\n\t\t\t\t);\n\t\t\t\ti += word.length - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//Stop the heredoc or the nowdoc if it's the word that has generated it\n\t\t\tif ((bufferType === \"nowdoc\" || bufferType === \"heredoc\") && word === heredocWord &&\n                    source.charAt(i - 1) === \"\\n\" &&\n                    heredocEndFollowing.test(source.substr(i + word.length))) {\n\t\t\t\temitBuffer();\n\t\t\t\temitToken(word, tokens.T_END_HEREDOC);\n\t\t\t\ti += word.length - 1;\n\t\t\t\tcontinue;\n\t\t\t} else if ((bufferType === \"heredoc\" || bufferType === \"doubleQuotes\")) {\n\t\t\t\tif (lastToken === \"[\") {\n\t\t\t\t\t//Literal array index inside a heredoc or a double quoted string\n\t\t\t\t\temitToken(word, tokens.T_STRING, true);\n\t\t\t\t\ti += word.length - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (lastToken === tokens.T_OBJECT_OPERATOR) {\n\t\t\t\t\t//Syntax $obj->prop inside strings and heredoc\n\t\t\t\t\temitToken(word, tokens.T_STRING, true);\n\t\t\t\t\ti += word.length - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (complexVarPrevBuffer && lastToken === tokens.T_DOLLAR_OPEN_CURLY_BRACES) {\n\t\t\t\t//Complex variable syntax  ${varname}\n\t\t\t\temitToken(word, tokens.T_STRING_VARNAME);\n\t\t\t\ti += word.length - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\temitToken(word, tokens.T_STRING);\n\t\t\ti += word.length - 1;\n\t\t} else if (ASCII < 32) {\n\t\t\t//If below ASCII 32 it's a bad character\n\t\t\temitToken(ch, tokens.T_BAD_CHARACTER);\n\t\t} else {\n\t\t\t//If there isn't an open buffer there should be an syntax error, but we don't care\n\t\t\t//so it will be emitted as a simple string\n\t\t\temitToken(ch, tokens.T_STRING);\n\t\t}\n\t}\n\t//If there's an open buffer emit it\n\tif (bufferType && (bufferType !== \"doubleQuotes\" || !split)) {\n\t\temitBuffer();\n\t} else {\n\t\tsplitString();\n\t}\n\treturn ret;\n};\n};\n"}